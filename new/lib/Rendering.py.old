#!/bin/python3
import curses as c

from .Constants import Flairs, FlairSymbols
from .Entry import Entry
from .EntryList import EntryList

class Listview:
    """
    Handles the rendering logic for the ncurses interface.
    It draws the current flat list of items (EntryList or Entry objects).
    """
    def __init__(self, app_instance):
        self.app = app_instance
        self.window = app_instance.window

    def draw(self, flat_items, cursor_y, scroll_y, scroll_x):
        """
        Draws the items onto the ncurses window, respecting the scroll and cursor state.
        :param flat_items: A list of dicts, where each dict has 'type' and 'data'.
        :param cursor_y: The index of the currently selected item.
        :param scroll_y: The top row index of the item being displayed.
        :param scroll_x: The horizontal scroll offset.
        """
        self.window.clear()
        
        max_y, max_x = self.window.getmaxyx()
        display_height = max_y - 1 # Reserve last line for status/command bar

        # Only draw the visible slice of items
        visible_items = flat_items[scroll_y : scroll_y + display_height]

        for list_index, item_wrapper in enumerate(visible_items):
            item = item_wrapper['data']
            item_type = item_wrapper['type']
            
            # Global index of the item
            global_index = scroll_y + list_index
            is_selected = (global_index == cursor_y)

            # --- Determine Text and Color ---
            
            if item_type == 'list':
                flair_key = Flairs.inf
                text = f"  {item.getName()} ({len(item.getEntries())} items)"
            elif item_type == 'entry':
                flair_key = item.getFlair()
                text = f"  {item.getTitle()}"
            else:
                flair_key = Flairs.err
                text = "  [Unknown Item Type]"

            symbol = FlairSymbols.convert.get(flair_key, "[?] ")
            color_id = FlairSymbols.COLOR_ID.get(flair_key, 1) # Default color 1
            color_pair = c.color_pair(color_id)

            # Prepend the symbol
            display_text = symbol + text
            
            # --- Apply Attributes and Draw ---
            row_attr = color_pair
            
            if is_selected:
                row_attr |= c.A_REVERSE

            # Handle horizontal scrolling
            line_to_draw = display_text[scroll_x:]
            
            # Truncate and pad the string for display
            padded_line = line_to_draw.ljust(max_x)
            
            try:
                # Add line, truncate to fit screen width
                self.window.addstr(list_index, 0, padded_line[:max_x], row_attr)
            except c.error:
                pass # Ignore error if cursor goes past screen edge

        # Draw the command/status bar
        self._draw_status_bar(max_y, max_x, cursor_y, len(flat_items), self.app.currentScreen)
        
        self.window.refresh()


    def _draw_status_bar(self, max_y, max_x, cursor_y, total_items, current_screen):
        """Draws the status/command bar on the bottom line."""
        
        # Determine current view name and commands
        if current_screen == 0:
            view_name = "LISTS"
            commands = "(A)dd list, (D)elete, (N)ame, (J/K) nav, (->/Enter) Open, (Q/X)uit"
        else:
            view_name = "ENTRIES"
            commands = "(A)dd task, (D)elete, (E)dit, (Space) Flip, (J/K) nav, (<-) Back, (Q/X)uit"

        status_text = f"[{view_name}] Line {cursor_y + 1}/{total_items} | {commands}"
        
        # Use a special color for the status bar
        status_color = c.color_pair(FlairSymbols.COLOR_ID.get(Flairs.inf, -1)) | c.A_BOLD
        
        # Clear the bottom line
        self.window.move(max_y - 1, 0)
        self.window.clrtoeol()
        
        # Draw the status text
        try:
            display_text = status_text.ljust(max_x)[:max_x]
            self.window.addstr(max_y - 1, 0, display_text, status_color)
        except c.error:
            pass
