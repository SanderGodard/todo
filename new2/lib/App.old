#!/bin/python3
import curses as c
import os
from time import sleep

# Updated imports
from .Constants import Keybinds, Flairs, FlairSymbols, ColorPairs
from .Entry import Entry
from .EntryList import EntryList
from .Rendering import Rendering


class App:
    """
    Main controller for the ncurses UI. Manages state, handles input,
    and orchestrates rendering via Rendering.
    """
    def __init__(self, stdscr):
        # curses window object
        self.window = stdscr
        self.window.keypad(True)
        self.max_y, self.max_x = self.window.getmaxyx()

        # Application state
        self.data_store = None # Set in start()
        self.currentScreen = 0
        self.chosenEntryList = None

        # View state
        self.cursor_y = 0
        self.scroll_y = 0
        self.scroll_x = 0
        self.flat_items = []
        self.is_editing = False
        self._needs_redraw = True # Flag to prevent unnecessary redraws (flickering fix)

        self.set_shorter_esc_delay_in_os()
        c.curs_set(0) # Invisible cursor normally
        c.noecho() # Don't echo input

        self._setup_colors()

        self.listview = Rendering(self)

    def set_shorter_esc_delay_in_os(self):
        """Sets the delay for ESC key to prevent input lag."""
        try:
            os.environ.setdefault('ESCDELAY', '5')
        except Exception:
            pass

    def _setup_colors(self):
        """Initialize color pairs for drawing based on FlairSymbols."""
        if c.has_colors():
            c.use_default_colors()
            c.start_color()

            # 1. Initialize pairs for Flairs (used for symbols)
            for flair, color_id in FlairSymbols.COLOR_MAP.items():
                fg_color = FlairSymbols.COLOR_MAP.get(flair, c.COLOR_WHITE)
                c.init_pair(color_id, fg_color, FlairSymbols.BG_COLOR)

            # 2. Initialize a separate pair for main text (transparent BG, standard FG)
            c.init_pair(ColorPairs.DEFAULT_TEXT, c.COLOR_WHITE, FlairSymbols.BG_COLOR)

    def _flatten_data(self):
        """
        Creates the flat list of items to display (lists or entries)
        and recalculates view limits.
        """
        self.flat_items = []

        if self.currentScreen == 0:
            # Use the sorted list from the data store
            for elist in self.data_store.getEntryLists():
                self.flat_items.append({'type': 'list', 'data': elist})

        elif self.currentScreen == 1 and self.chosenEntryList:
            # Entries are displayed in the exact order they are stored in EntryList.
            for entry in self.chosenEntryList.getEntries():
                self.flat_items.append({'type': 'entry', 'data': entry})

        # Clamp cursor and scroll positions
        total_items = len(self.flat_items)
        display_height = self.max_y - 1

        self.cursor_y = min(self.cursor_y, total_items - 1)
        self.cursor_y = max(0, self.cursor_y)

        if self.cursor_y < self.scroll_y:
            self.scroll_y = self.cursor_y
        if self.cursor_y >= self.scroll_y + display_height:
            self.scroll_y = self.cursor_y - display_height + 1

        self.scroll_y = max(0, self.scroll_y)
        self.scroll_x = max(0, self.scroll_x)


    def _get_selected_item(self):
        """Returns the currently selected item object."""
        if 0 <= self.cursor_y < len(self.flat_items):
            return self.flat_items[self.cursor_y]['data']
        return None

    def _get_selected_item_type(self):
        """Returns the type of the currently selected item ('list' or 'entry')."""
        if 0 <= self.cursor_y < len(self.flat_items):
            return self.flat_items[self.cursor_y]['type']
        return None

    def _handle_move(self, key):
        """Handles moving the selected entry up or down in the list using Shift+Arrows."""

        # Only allow reordering entries (Screen 1)
        if self.currentScreen != 1 or self._get_selected_item_type() != 'entry':
            return

        direction = 0
        if key in Keybinds.SHIFT_UP:
            direction = -1
        elif key in Keybinds.SHIFT_DOWN:
            direction = 1
        else:
            return

        if self.chosenEntryList:
            old_index = self.cursor_y

            self.chosenEntryList.move_entry(old_index, direction)

            # Move the cursor along with the item
            if 0 <= self.cursor_y + direction < len(self.flat_items):
                self.cursor_y += direction

            self._flatten_data()
            self._needs_redraw = True

    def _handle_navigation(self, key):
        """Handles cursor movement and scrolling."""
        initial_cursor = self.cursor_y

        if key in Keybinds.UP:
            if self.cursor_y > 0:
                self.cursor_y -= 1

        elif key in Keybinds.DOWN:
            if self.cursor_y < len(self.flat_items) - 1:
                self.cursor_y += 1

        elif key in Keybinds.LEFT:
            self.scroll_x = max(0, self.scroll_x - 4)
        elif key in Keybinds.RIGHT:
            self.scroll_x += 4

        if initial_cursor != self.cursor_y or key in Keybinds.LEFT or key in Keybinds.RIGHT:
            self._flatten_data()
            self._needs_redraw = True

    def _handle_delete(self):
        """Deletes the selected list or entry."""
        item = self._get_selected_item()
        if not item:
            return

        item.delete()

        if self.currentScreen == 0 and not self.data_store.getEntryLists():
            # If all lists are deleted, create a new default one
            self.data_store.addEntryList()

        elif self.currentScreen == 1 and self.chosenEntryList and not self.chosenEntryList.getEntries():
            # If all entries are deleted, go back to list view
            self.currentScreen = 0
            self.chosenEntryList = None

        self.cursor_y = max(0, self.cursor_y - 1)
        self._flatten_data()
        self._needs_redraw = True

    def _handle_add(self):
        """Adds a new list or entry."""
        if self.currentScreen == 0:
            self.data_store.addEntryList()
        elif self.currentScreen == 1 and self.chosenEntryList:
            self.chosenEntryList.addEntry()

        self._flatten_data()
        self.cursor_y = len(self.flat_items) - 1
        self._needs_redraw = True


    def _handle_rename_or_edit(self):
        """Handles in-place text editing."""
        item = self._get_selected_item()
        if not item:
            return

        # Get the screen position of the selected item
        edit_y = self.cursor_y - self.scroll_y

        # 1. Determine the starting column for the editable text
        item_type = self._get_selected_item_type()
        flair_symbol_len = 0

        # Calculate the length of the symbol/flair prefix to find the text start column
        if item_type == 'list':
            flair_symbol = FlairSymbols.convert.get(Flairs.inf, FlairSymbols.convert[Flairs.inf])
            flair_symbol_len = len(flair_symbol)
        elif item_type == 'entry':
            flair = item.getFlair()
            flair_symbol = FlairSymbols.convert.get(flair, FlairSymbols.convert[Flairs.tsk])
            flair_symbol_len = len(flair_symbol)

        # The text starts after the symbol, adjusted for horizontal scrolling (scroll_x)
        # edit_x is the screen column where the first editable character appears.
        edit_x = max(0, flair_symbol_len - self.scroll_x)

        # If the start of the text is scrolled off screen, we cannot edit
        if edit_x >= self.max_x - 1:
            return

        initial_text = item.getTitle()
        new_text = initial_text
        cursor_pos = len(new_text) # Cursor position within the `new_text` string

        # Set up terminal for editing
        self.is_editing = True
        c.curs_set(1) # Visible cursor
        c.echo() # Echo characters to screen
        self.window.nodelay(False) # Wait for input

        while True:
            # 2. Redraw the list line with the current text
            self.window.move(edit_y, 0)

            # Use the correct color/attribute for the *entire* line for the background
            row_attr = c.A_REVERSE # Always reverse for edit mode visibility
            #row_attr = c.A_NORMAL

            # The part of the input line *before* the editable text (Flair symbol)
            prefix = flair_symbol

            # Calculate what part of the prefix is visible due to scroll_x
            visible_prefix = prefix[self.scroll_x:]

            # Calculate horizontal scrolling for the text itself
            display_start_col = 0 # Character index in new_text to start displaying

            # Check if the cursor is past the visible screen area for the text
            # We calculate this based on the cursor position relative to the starting column edit_x
            max_text_width = self.max_x - edit_x
            if cursor_pos >= max_text_width:
                # Calculate the scroll offset for the text itself
                display_start_col = cursor_pos - max_text_width + 1

            # The current text content visible, considering horizontal text scroll
            visible_text_content = new_text[display_start_col:]

            # Combine visible prefix and text content
            full_visible_line = visible_prefix + visible_text_content

            # Truncate and pad the full line to ensure safe drawing
            line_to_draw = full_visible_line[:self.max_x - 1].ljust(self.max_x - 1)

            # Draw the line
            self.window.addstr(edit_y, 0, line_to_draw, row_attr)

            # Move the cursor to the correct position (Screen x position)
            # screen_cursor_x = (start_column of text) + (cursor_pos in text) - (text_scroll_offset)
            screen_cursor_x = edit_x + (cursor_pos - display_start_col)

            self.window.move(edit_y, min(self.max_x - 1, screen_cursor_x))
            self.window.refresh()

            # 3. Get Input
            key = self.window.getch()

            if key in Keybinds.ESCAPE:
                # Escape reverts changes
                break
            elif key in Keybinds.ENTER:
                if new_text.strip():
                    item.edit(new_text.strip())
                # If editing a list, make sure to reload the lists in case of sorting by name
                if item_type == 'list':
                    self.data_store.sortEntryLists()
                break
            elif key in Keybinds.backspace:
                if cursor_pos > 0:
                    new_text = new_text[:cursor_pos-1] + new_text[cursor_pos:]
                    cursor_pos -= 1
            elif key in Keybinds.delete:
                if cursor_pos < len(new_text):
                    new_text = new_text[:cursor_pos] + new_text[cursor_pos+1:]
            elif key == c.KEY_LEFT:
                cursor_pos = max(0, cursor_pos - 1)
            elif key == c.KEY_RIGHT:
                cursor_pos = min(len(new_text), cursor_pos + 1)
            elif 32 <= key <= 255: # Printable characters
                char = chr(key)
                new_text = new_text[:cursor_pos] + char + new_text[cursor_pos:]
                cursor_pos += 1

        # Restore terminal state
        self.is_editing = False
        c.curs_set(0)
        c.noecho()
        self.window.nodelay(True)
        # Force a full redraw to repaint the line without the reverse attribute
        self._flatten_data()
        self._needs_redraw = True


    def _handle_view_switch(self, key):
        """Handles switching between list selection (0) and entry view (1)."""
        if self.currentScreen == 0:
            item = self._get_selected_item()
            if self._get_selected_item_type() == 'list':
                self.chosenEntryList = item
                self.currentScreen = 1

        elif self.currentScreen == 1:
            self.currentScreen = 0
            self.chosenEntryList = None

        # Reset view state for the new screen
        self.cursor_y = 0
        self.scroll_y = 0
        self.scroll_x = 0
        self._flatten_data()
        self._needs_redraw = True

    def handle_input(self, key):
        """Processes a single keypress event."""

        if key in Keybinds.QUIT:
            return False

        # Handle item movement (Shift+Arrows)
        if key in Keybinds.SHIFT_UP or key in Keybinds.SHIFT_DOWN:
            self._handle_move(key)
            return True

        if key in Keybinds.UP or key in Keybinds.DOWN or key in Keybinds.LEFT or key in Keybinds.RIGHT:
            self._handle_navigation(key)

        elif key in Keybinds.ADD:
            self._handle_add()

        elif key in Keybinds.DELETE_ITEM:
            self._handle_delete()

        elif key in Keybinds.RENAME or key in Keybinds.EDIT:
            self._handle_rename_or_edit()

        if self.currentScreen == 0:
            if key in Keybinds.ENTER or key in Keybinds.RIGHT:
                self._handle_view_switch(key)

        elif self.currentScreen == 1:
            if key in Keybinds.LEFT:
                self._handle_view_switch(key)

            elif key in Keybinds.FLIP:
                item = self._get_selected_item()
                if self._get_selected_item_type() == 'entry':
                    item.flip()
                    self._needs_redraw = True

        return True

    # Main Loop
    def start(self, data_store):
        """
        Main application loop.
        """
        self.data_store = data_store
        self._flatten_data()
        self.window.nodelay(True)

        running = True

        while running:
            # 1. Check for terminal resize
            new_max_y, new_max_x = self.window.getmaxyx()
            if new_max_y != self.max_y or new_max_x != self.max_x:
                self.max_y, self.max_x = new_max_y, new_max_x
                self._flatten_data()
                self._needs_redraw = True

            # 2. Input
            key = self.window.getch()

            if key != c.ERR and key != -1:
                running = self.handle_input(key)

            # 3. Rendering - Only draw if something has changed (Flickering Fix)
            if self._needs_redraw and not self.is_editing:
                self.listview.draw(self.flat_items, self.cursor_y, self.scroll_y, self.scroll_x)
                self.window.refresh()
                self._needs_redraw = False

            sleep(0.01)

        # Save data when exiting
        self.data_store.save()
