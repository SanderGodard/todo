#!/bin/python3
import curses as c
from .Constants import Flairs, FlairSymbols, ColorPairs

class Rendering:
    """
    Handles all visual output to the ncurses window based on App state.
    (Previously Listview.py)
    """
    def __init__(self, app):
        self.app = app
        self.window = app.window
        

    def draw(self, items, cursor_y, scroll_y, scroll_x, is_editing):
        """
        Draws the main list, applying appropriate flair, colors, and handling scrolling.
        """
        self.window.clear()
        max_y, max_x = self.window.getmaxyx()
        display_height = max_y - 1 # Reserve bottom row for status/edit
        
        # --- Draw List Items ---
        for list_index in range(display_height):
            abs_index = list_index + scroll_y
            
            if abs_index < len(items):
                item_data = items[abs_index]
                item = item_data['data']
                item_type = item_data['type']
                
                is_selected = (abs_index == cursor_y)
                
                row_attr = c.A_NORMAL
                
                # Default text color for the body of the entry/list name
                text_color_pair = c.color_pair(ColorPairs.DEFAULT_TEXT) 
                
                # 1. Determine Flair/Symbol and Text
                if item_type == 'list':
                    flair = Flairs.inf
                    flair_symbol = FlairSymbols.convert.get(flair, FlairSymbols.convert[Flairs.inf])
                    text = f"{item.getTitle()}"
                    flair_color_pair = c.color_pair(FlairSymbols.COLOR_MAP.get(flair, c.COLOR_MAGENTA))
                
                else: # item_type == 'entry'
                    flair = item.getFlair()
                    flair_symbol = FlairSymbols.convert.get(flair, FlairSymbols.convert[Flairs.prt])
                    text = f"{item.getTitle()}"
                    flair_color_pair = c.color_pair(FlairSymbols.COLOR_MAP.get(flair, c.COLOR_RED))

                # If selected, reverse only the flair, but keep the text normal.
                # If in edit mode AND selected, use the PRT flair color for the flair.
                if is_selected and is_editing:
                    # When editing, flair should use the PRT color for visibility
                    flair_color_pair = c.color_pair(ColorPairs.PRT_FLAIR)
                    flair_attr = c.A_BOLD # Add boldness to flair in edit mode
                elif is_selected:
                    # When selected, only the flair is reversed, text remains normal color
                    flair_attr = c.A_REVERSE
                else:
                    flair_attr = c.A_NORMAL

                # 2. Prepare combined line for background drawing
                full_line = f"{flair_symbol}{text}"
                
                # Apply scrolling offset
                visible_line = full_line[scroll_x:]
                
                # **FIXED:** Truncate and pad to a maximum length of max_x - 1 to stay within bounds [0, max_x - 2]
                display_line_content = visible_line[:max_x - 1]
                display_line = display_line_content.ljust(max_x - 1)
                
                
                # 3. Draw Background and Selection
                self.window.attrset(row_attr)
                if is_selected:
                    row_attr |= c.A_NORMAL
                #    row_attr |= c.A_REVERSE
                
                self.window.attrset(row_attr)
                self.window.addstr(list_index, 0, display_line)
                
                # 4. Draw Flair Symbol Color Overlay (if visible)
                symbol_len = len(flair_symbol)
                
                # Check if the flair symbol is still partially visible on screen
                if scroll_x < symbol_len:
                    # The visible portion of the symbol starts at scroll_x index of the flair string.
                    visible_symbol_part = flair_symbol[scroll_x:]
                    
                    # Ensure we only draw up to the edge of the screen (max_x - 1 characters)
                    display_symbol = visible_symbol_part[:max_x - 1]

                    self.window.attrset(row_attr | flair_color_pair)
                    self.window.addstr(list_index, 0, display_symbol)

                # 5. Draw Main Text Color Overlay
                
                # The screen column where the *text* starts
                text_draw_start_col = max(0, symbol_len - scroll_x)
                
                # The index in the 'text' string where the visible content starts
                text_start_index = max(0, scroll_x - symbol_len)

                # The actual text content to display from that point
                visible_text_content = text[text_start_index:]
                
                # Max length we can draw starting from text_draw_start_col (must be <= max_x - 1)
                max_draw_len = max_x - text_draw_start_col

                if max_draw_len > 0 and text_draw_start_col < max_x:
                    # Truncate and pad the visible text content to fill the remainder of the line
                    display_text_for_color = visible_text_content.ljust(max_draw_len)[:max_draw_len]
                    
                    self.window.attrset(row_attr | text_color_pair)
                    self.window.addstr(list_index, text_draw_start_col, display_text_for_color)


        
        # --- Draw Status Bar ---
        status_text = self._get_status_text(cursor_y, len(items), scroll_y)
        self.window.attrset(c.A_NORMAL | c.color_pair(FlairSymbols.COLOR_MAP[Flairs.inf]) | c.A_REVERSE)
        
        # **FIXED:** Truncate to max_x - 1 and pad to cover the entire line safely
        status_line_content = status_text[:max_x - 1].ljust(max_x - 1)
        self.window.addstr(max_y - 1, 0, status_line_content)

    
    def _get_status_text(self, cursor_y, total_items, scroll_y):
        """Constructs the text for the bottom status bar."""
        app = self.app
        if app.currentScreen == 0:
            header = "MAIN (Lists)"
        else:
            header = f"LIST: {app.chosenEntryList.getName()}"

        
        pos_text = f"Pos: {cursor_y + 1}/{total_items}"
        scroll_text = f"Scroll: Y={scroll_y} X={app.scroll_x}"

        # Instructions based on screen
        if app.currentScreen == 1:
            instructions = "a: Add | d/DEL: Del | r/e: Edit | SPACE: Flip | x/q/ESC: Back | SHIFT+^/v: Move"
        else:
            instructions = "a: Add | d/DEL: Del | r/e: Edit | ENTER/->: Open | x/q/ESC: Quit"
        
        status_line = f" {header} | {instructions} | {pos_text} | {scroll_text}"
        
        return status_line
